# 백엔드 완벽 가이드 - Minute AI 시스템
## 인쇄용 버전

> 백엔드 & 데이터베이스 완전 정복
> 작성일: 2025-11-11

---

## 목차

### 1부. 시스템 아키텍처
1. [전체 시스템 구조](#1-전체-시스템-구조)
2. [기술 스택](#2-기술-스택)
3. [디렉토리 구조](#3-디렉토리-구조)

### 2부. 데이터베이스 설계
4. [SQLite 스키마](#4-sqlite-스키마)
5. [ChromaDB 컬렉션](#5-chromadb-컬렉션)
6. [데이터 흐름](#6-데이터-흐름)

### 3부. 백엔드 코어 모듈
7. [Flask 애플리케이션](#7-flask-애플리케이션)
8. [음성 인식 모듈](#8-음성-인식-모듈)
9. [데이터베이스 관리자](#9-데이터베이스-관리자)
10. [벡터 DB 관리자](#10-벡터-db-관리자)
11. [RAG 챗봇](#11-rag-챗봇)
12. [사용자 권한 관리](#12-사용자-권한-관리)

### 4부. API 엔드포인트
13. [인증 API](#13-인증-api)
14. [파일 업로드 API](#14-파일-업로드-api)
15. [회의록 CRUD API](#15-회의록-crud-api)
16. [챗봇 API](#16-챗봇-api)
17. [공유 API](#17-공유-api)

### 5부. 실전 가이드
18. [회의록 생성 프로세스](#18-회의록-생성-프로세스)
19. [챗봇 질의 프로세스](#19-챗봇-질의-프로세스)
20. [회의록 삭제 프로세스](#20-회의록-삭제-프로세스)

### 6부. 최적화 & 보안
21. [데이터베이스 최적화](#21-데이터베이스-최적화)
22. [보안 Best Practice](#22-보안-best-practice)
23. [에러 핸들링](#23-에러-핸들링)

---

# 1부. 시스템 아키텍처

## 1. 전체 시스템 구조

### 레이어 구조
- **프레젠테이션 계층**: Flask 웹 애플리케이션 (app.py)
- **비즈니스 로직 계층**: Utils 모듈 (stt, db_manager, vector_db, chat_manager)
- **데이터 계층**: SQLite + ChromaDB
- **외부 API 계층**: Gemini AI, Firebase Auth, OpenAI

### 주요 컴포넌트
1. **Flask Application (app.py)**: HTTP 요청/응답 처리
2. **STT Manager (utils/stt.py)**: 음성 인식 및 AI 생성
3. **Database Manager (utils/db_manager.py)**: SQLite CRUD 작업
4. **Vector DB Manager (utils/vector_db_manager.py)**: ChromaDB 벡터 관리
5. **Chat Manager (utils/chat_manager.py)**: RAG 챗봇 엔진
6. **User Manager (utils/user_manager.py)**: 사용자 및 권한 관리

---

## 2. 기술 스택

| 계층 | 기술 | 용도 |
|------|------|------|
| 웹 프레임워크 | Flask 3.0 | HTTP 요청/응답 처리 |
| WSGI | Werkzeug | 개발 서버, 파일 업로드 |
| 관계형 DB | SQLite3 | 메타데이터 저장 |
| 벡터 DB | ChromaDB + LangChain | RAG 검색 |
| AI - STT/요약 | Gemini 2.5 Pro/Flash | 음성 인식, 요약, 챗봇 |
| AI - 임베딩 | OpenAI text-embedding-3-small | 벡터화 (1536차원) |
| 인증 | Firebase Auth | 구글 OAuth |

---

## 3. 디렉토리 구조

```
minute_ai/
├── app.py                      # Flask 메인 애플리케이션
├── utils/                      # 핵심 비즈니스 로직
│   ├── stt.py                 # 음성 인식 & AI 생성
│   ├── db_manager.py          # SQLite CRUD
│   ├── vector_db_manager.py   # ChromaDB 관리
│   ├── chat_manager.py        # RAG 챗봇
│   ├── user_manager.py        # 사용자/권한 관리
│   ├── firebase_auth.py       # Firebase 인증
│   ├── validation.py          # 입력값 검증
│   ├── decorators.py          # 인증 데코레이터
│   └── analysis.py            # 화자 분석
├── database/
│   ├── minute_ai.db           # SQLite 파일
│   └── vector_db/             # ChromaDB 데이터
├── uploads/                    # 업로드 파일 저장소
└── templates/                  # Jinja2 템플릿
```

---

# 2부. 데이터베이스 설계

## 4. SQLite 스키마

### 4.1 users 테이블

**역할**: Firebase 사용자와 내부 user_id 매핑

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    firebase_uid TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    display_name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP
);
```

**주요 쿼리**:
- 사용자 조회: `SELECT * FROM users WHERE firebase_uid = ?`
- 사용자 생성: `INSERT INTO users (firebase_uid, email, display_name) VALUES (?, ?, ?)`

---

### 4.2 meetings 테이블

**역할**: 회의 메타데이터 저장

```sql
CREATE TABLE meetings (
    id TEXT PRIMARY KEY,              -- UUID v4
    title TEXT NOT NULL,
    meeting_date TIMESTAMP NOT NULL,
    audio_file TEXT NOT NULL,
    owner_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (owner_id) REFERENCES users(id)
);

-- 인덱스
CREATE INDEX idx_meetings_owner ON meetings(owner_id);
CREATE INDEX idx_meetings_date ON meetings(meeting_date DESC);
```

**주요 쿼리**:
- 본인 회의 조회: `SELECT * FROM meetings WHERE owner_id = ? ORDER BY meeting_date DESC`
- 특정 회의 조회: `SELECT * FROM meetings WHERE id = ?`

---

### 4.3 meeting_dialogues 테이블

**역할**: 회의 대화 내용 저장 (STT 결과)

```sql
CREATE TABLE meeting_dialogues (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    meeting_id TEXT NOT NULL,
    speaker_label TEXT NOT NULL,      -- "화자1", "화자2"...
    start_time REAL NOT NULL,         -- 시작 시간 (초)
    segment TEXT NOT NULL,            -- 대화 내용
    confidence REAL,                  -- 신뢰도 (0.0-1.0)
    FOREIGN KEY (meeting_id) REFERENCES meetings(id) ON DELETE CASCADE
);

-- 인덱스
CREATE INDEX idx_dialogues_meeting ON meeting_dialogues(meeting_id);
CREATE INDEX idx_dialogues_time ON meeting_dialogues(start_time);
```

**주요 쿼리**:
- 전체 대화 조회: `SELECT * FROM meeting_dialogues WHERE meeting_id = ? ORDER BY start_time ASC`
- 특정 화자 발언: `SELECT * FROM meeting_dialogues WHERE meeting_id = ? AND speaker_label = ?`

---

### 4.4 meeting_minutes 테이블

**역할**: 회의록 및 마인드맵 저장

```sql
CREATE TABLE meeting_minutes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    meeting_id TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    meeting_date TIMESTAMP NOT NULL,
    content TEXT NOT NULL,            -- 마크다운 회의록
    mindmap_content TEXT,             -- 마크다운 마인드맵
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (meeting_id) REFERENCES meetings(id) ON DELETE CASCADE
);
```

**주요 쿼리**:
- 회의록 조회: `SELECT content, mindmap_content FROM meeting_minutes WHERE meeting_id = ?`

---

### 4.5 meeting_shares 테이블

**역할**: 회의록 공유 관리

```sql
CREATE TABLE meeting_shares (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    meeting_id TEXT NOT NULL,
    shared_with_user_id INTEGER NOT NULL,
    permission TEXT DEFAULT 'read',   -- 'read', 'write', 'admin'
    shared_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (meeting_id) REFERENCES meetings(id) ON DELETE CASCADE,
    FOREIGN KEY (shared_with_user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(meeting_id, shared_with_user_id)
);
```

**권한 체크 로직**:
```python
# 접근 가능 조건: 본인 소유 OR 공유받음 OR 관리자
def can_access_meeting(user_id, meeting_id):
    # 1. 본인 소유 확인
    meeting = db.execute("SELECT owner_id FROM meetings WHERE id = ?", (meeting_id,))
    if meeting and meeting['owner_id'] == user_id:
        return True

    # 2. 공유 확인
    share = db.execute("""
        SELECT 1 FROM meeting_shares
        WHERE meeting_id = ? AND shared_with_user_id = ?
    """, (meeting_id, user_id))
    if share:
        return True

    # 3. 관리자 확인
    if is_admin(user_id):
        return True

    return False
```

---

## 5. ChromaDB 컬렉션

### 5.1 meeting_chunks 컬렉션

**목적**: 실제 대화 내용 저장 (RAG 검색용)

**Document 구조**:
```python
{
    "id": "{meeting_id}_chunk_{index}",
    "text": "청크 텍스트 (화자/시간 정보 제거됨)",
    "metadata": {
        "meeting_id": "uuid",
        "dialogue_id": "{meeting_id}_chunk_{index}",
        "chunk_index": 0,
        "title": "회의 제목",
        "meeting_date": "2025-11-10",
        "audio_file": "uuid.mp3",
        "start_time": 120.5,
        "end_time": 180.2,
        "speaker_count": 2
    },
    "embedding": [0.1, 0.2, ...]  # 1536차원 벡터 (OpenAI)
}
```

**스마트 청킹 알고리즘**:
- **화자 변경**: 화자가 바뀌고 현재 청크가 500자 이상이면 분리
- **시간 간격**: 60초 이상 침묵 + 200자 이상이면 분리
- **크기 제한**: 1000자 초과 시 강제 분리

코드 위치: `utils/vector_db_manager.py:230-308`

---

### 5.2 meeting_subtopic 컬렉션

**목적**: 주제별 요약 저장 (RAG 검색용)

**Document 구조**:
```python
{
    "id": "{meeting_id}_summary_{index}",
    "text": "요약 텍스트 (마크다운)",
    "metadata": {
        "meeting_id": "uuid",
        "meeting_title": "회의 제목",
        "meeting_date": "2025-11-10",
        "audio_file": "uuid.mp3",
        "main_topic": "주제 제목",
        "summary_index": 0
    },
    "embedding": [0.1, 0.2, ...]
}
```

**생성 방식**:
1. Gemini로 주제별 요약 생성
2. `### 제목` 으로 요약 분리
3. 각 주제별로 별도 Document로 저장

코드 위치: `utils/vector_db_manager.py:311-363`

---

## 6. 데이터 흐름

### 6.1 파일 업로드 → 회의록 생성

```
[1] 파일 업로드 (app.py)
    ↓
[2] 파일 검증 및 저장 (uploads/)
    ↓
[3] MP4 → WAV 변환 (필요시)
    ↓
[4] Gemini STT 실행 (stt.py)
    → segments: [{speaker, start_time, text, confidence}]
    ↓
[5] SQLite 저장 (db_manager.py)
    → meetings 테이블
    → meeting_dialogues 테이블
    ↓
[6] 스마트 청킹 (vector_db_manager.py)
    → 화자/시간/크기 고려
    → 텍스트 정제 (정규표현식)
    ↓
[7] ChromaDB 저장
    → meeting_chunks 컬렉션
    ↓
[8] 요약 생성 (stt.py)
    → Gemini Flash로 주제별 요약
    ↓
[9] ChromaDB 저장
    → meeting_subtopic 컬렉션
    ↓
[10] 마인드맵 생성 (stt.py)
    → Gemini Flash로 마크다운 마인드맵
    ↓
[11] SQLite 저장
    → meeting_minutes 테이블
```

**소요 시간 (30분 회의 기준)**:
- STT: 2-3분
- 청킹 & 임베딩: 30초
- 요약 생성: 30초
- 마인드맵: 20초
- **총 약 4분**

---

# 3부. 백엔드 코어 모듈

## 7. Flask 애플리케이션

### 7.1 초기화 (app.py:36-69)

```python
app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('FLASK_SECRET_KEY')
app.config['UPLOAD_FOLDER'] = "./uploads"
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB

# 전역 객체 초기화
db = DatabaseManager(DB_PATH)
stt_manager = STTManager()
vdb_manager.db_manager = db
chat_manager = ChatManager(vdb_manager, retriever_type="similarity")
```

### 7.2 주요 라우트

**인증**:
- `/login`: 로그인 페이지
- `/api/login`: Firebase 인증 처리
- `/logout`: 로그아웃

**메인**:
- `/`: 회의록 목록 (본인 소유 + 공유받은 것)
- `/viewer/<meeting_id>`: 회의록 상세보기
- `/shared-notes`: 공유받은 노트 목록

**파일 처리**:
- `/api/upload`: 파일 업로드 & 전체 파이프라인
- `/api/upload_with_progress`: SSE로 진행률 전송
- `/api/script`: 텍스트 직접 입력 (STT 생략)

**CRUD**:
- `/api/meeting/<meeting_id>`: 회의 정보 조회
- `/api/update_title/<meeting_id>`: 제목 수정
- `/api/delete_meeting/<meeting_id>`: 회의 삭제

**챗봇**:
- `/api/chat`: RAG 챗봇 질의

**공유**:
- `/api/share/<meeting_id>`: 회의록 공유
- `/api/unshare/<meeting_id>/<user_id>`: 공유 취소
- `/api/shared_users/<meeting_id>`: 공유 목록 조회

---

## 8. 음성 인식 모듈

### 8.1 STT 실행 (utils/stt.py:29-152)

**주요 기능**:
1. Gemini 2.5 Pro로 음성 인식
2. 화자 분리 (Speaker Diarization)
3. 타임스탬프 추출
4. 신뢰도 점수 계산

**프롬프트 핵심 지침**:
- 충실도 우선: 실제 발화 내용만 인식
- 문장 보정 금지
- 화자 일관성 유지
- JSON 형식 출력

**출력 형식**:
```json
[
    {
        "speaker": 1,
        "start_time_mmss": "0:00:000",
        "confidence": 0.95,
        "text": "안녕하세요. 회의를 시작하겠습니다."
    }
]
```

---

### 8.2 요약 생성 (utils/stt.py:154-271)

**Gemini Flash 사용 이유**: 속도 최적화 (Pro 대비 10배 빠름)

**출력 형식**:
```markdown
### 첫 번째 주요 주제
* 첫 번째 논의 내용 요약 [cite: 1]
* 두 번째 논의 내용 요약 [cite: 2, 3]

### 두 번째 주요 주제
* 세 번째 논의 내용 요약 [cite: 4]
```

**핵심 지침**:
- 주제별 그룹화
- `### 제목` 형식 필수
- 구어체 → 문어체 변환
- 화자 라벨 제거
- 인용 출처 명시

---

### 8.3 마인드맵 생성 (utils/stt.py:432-526)

**출력 형식**:
```markdown
# 1차회의
## 주요 안건
### 프로젝트 일정
- 11월 15일 완료
### 예산
- 20만원
```

**핵심 규칙**:
- 최상위(#)는 회의 제목만
- 2단계(##)부터 실제 주제
- 최대 깊이 4단계(####)
- 각 노드 5-10단어

---

## 9. 데이터베이스 관리자

### 9.1 주요 메서드 (utils/db_manager.py)

**연결 관리**:
```python
def _get_connection(self):
    """매 요청마다 새 연결 생성 (Thread-safe)"""
    conn = sqlite3.connect(self.db_path)
    conn.row_factory = sqlite3.Row  # Dict처럼 사용
    return conn
```

**회의 정보 저장**:
```python
def save_meeting_info(self, meeting_id, title, meeting_date, audio_file, owner_id):
    with self._get_connection() as conn:
        conn.execute("""
            INSERT INTO meetings (id, title, meeting_date, audio_file, owner_id)
            VALUES (?, ?, ?, ?, ?)
        """, (meeting_id, title, meeting_date, audio_file, owner_id))
        conn.commit()
```

**대화 저장**:
```python
def save_segment(self, meeting_id, speaker_label, start_time, segment, confidence):
    with self._get_connection() as conn:
        conn.execute("""
            INSERT INTO meeting_dialogues
            (meeting_id, speaker_label, start_time, segment, confidence)
            VALUES (?, ?, ?, ?, ?)
        """, (meeting_id, speaker_label, start_time, segment, confidence))
        conn.commit()
```

**회의 삭제** (Cascade):
```python
def delete_meeting(self, meeting_id):
    """
    meetings 삭제 → FK CASCADE로 자동 삭제:
    - meeting_dialogues
    - meeting_minutes
    - meeting_shares
    """
    with self._get_connection() as conn:
        # 오디오 파일 경로 조회
        meeting = conn.execute(
            "SELECT audio_file FROM meetings WHERE id = ?",
            (meeting_id,)
        ).fetchone()

        # DB 삭제
        conn.execute("DELETE FROM meetings WHERE id = ?", (meeting_id,))
        conn.commit()

        # 파일 삭제
        if meeting and meeting['audio_file']:
            file_path = os.path.join(UPLOAD_FOLDER, meeting['audio_file'])
            if os.path.exists(file_path):
                os.remove(file_path)
```

---

## 10. 벡터 DB 관리자

### 10.1 초기화 (utils/vector_db_manager.py:27-48)

```python
class VectorDBManager:
    def __init__(self):
        # ChromaDB 클라이언트
        self.client = chromadb.PersistentClient(path="./database/vector_db")

        # OpenAI Embeddings (1536차원)
        self.embeddings = OpenAIEmbeddings(
            model="text-embedding-3-small",
            openai_api_key=os.getenv("OPENAI_API_KEY")
        )

        # 2개 컬렉션
        self.vectorstores = {
            "chunks": Chroma(
                client=self.client,
                collection_name="meeting_chunks",
                embedding_function=self.embeddings
            ),
            "subtopic": Chroma(
                client=self.client,
                collection_name="meeting_subtopic",
                embedding_function=self.embeddings
            )
        }
```

---

### 10.2 스마트 청킹 (utils/vector_db_manager.py:230-308)

**청크 분리 조건**:
1. **크기 초과**: 1000자 초과 시 무조건 분리
2. **시간 간격**: 60초 이상 침묵 + 200자 이상
3. **화자 변경**: 화자 바뀜 + 500자 이상

```python
def _create_smart_chunks(self, segments, max_chunk_size=1000, time_gap_threshold=60):
    chunks = []
    current_chunk = []
    current_speaker = None
    last_time = 0
    speakers_in_chunk = set()

    for seg in segments:
        speaker = seg['speaker_label']
        start_time = seg['start_time']
        text = seg['segment']

        # 분리 조건 체크
        should_split = False

        if len(current_chunk_text) + len(text) > max_chunk_size:
            should_split = True
        elif (start_time - last_time) > time_gap_threshold and len(current_chunk_text) > 200:
            should_split = True
        elif speaker != current_speaker and len(current_chunk_text) > 500:
            should_split = True

        if should_split and current_chunk:
            # 청크 저장
            chunks.append({
                'text': current_chunk_text,
                'start_time': current_chunk[0]['start_time'],
                'end_time': current_chunk[-1]['start_time'],
                'speaker_count': len(speakers_in_chunk)
            })
            current_chunk = []
            speakers_in_chunk = set()

        current_chunk.append(seg)
        speakers_in_chunk.add(speaker)
        current_speaker = speaker
        last_time = start_time

    return chunks
```

---

### 10.3 벡터 검색 (utils/vector_db_manager.py:368-483)

**검색 타입**:
- **similarity**: 코사인 유사도 기반 (기본값)
- **mmr**: 다양성 고려 (Maximum Marginal Relevance)
- **self_query**: LLM이 메타데이터 필터 자동 생성

```python
def search(self, db_type, query, k=5, retriever_type="similarity", filter_criteria=None):
    """
    벡터 검색

    Args:
        db_type: "chunks" or "subtopic"
        query: 검색 쿼리
        k: 반환 개수
        retriever_type: "similarity", "mmr", "self_query"
        filter_criteria: {"meeting_id": "uuid"}

    Returns:
        List[Document]
    """
    vdb = self.vectorstores[db_type]

    search_kwargs = {'k': k}
    if filter_criteria:
        search_kwargs['filter'] = filter_criteria

    retriever = vdb.as_retriever(
        search_type=retriever_type,
        search_kwargs=search_kwargs
    )

    results = retriever.invoke(query)
    return results
```

---

## 11. RAG 챗봇

### 11.1 전체 파이프라인 (utils/chat_manager.py:319-387)

```python
def process_query(self, query, meeting_id=None, accessible_meeting_ids=None):
    """
    RAG 챗봇 메인 로직

    Flow:
    1. 문서 검색 (chunks 3개 + subtopic 3개)
    2. 컨텍스트 포맷팅
    3. Gemini로 답변 생성
    4. 출처 정보 추가
    """
    # 1. 검색
    search_results = self.search_documents(query, meeting_id, accessible_meeting_ids)

    if search_results["total_count"] == 0:
        return {
            "success": True,
            "answer": "관련 내용을 찾을 수 없습니다.",
            "sources": []
        }

    # 2. 컨텍스트 생성
    context = self.format_context(search_results)

    # 3. 답변 생성
    result = self.generate_answer(query, context)

    # 4. 출처 추가
    sources = []
    for doc in search_results["chunks"]:
        sources.append({
            "type": "chunk",
            "meeting_id": doc.metadata.get("meeting_id"),
            "title": doc.metadata.get("title"),
            "start_time": doc.metadata.get("start_time")
        })

    return {
        "success": True,
        "answer": result["answer"],
        "sources": sources
    }
```

---

### 11.2 이중 검색 (utils/chat_manager.py:39-204)

**검색 전략**:
- **단일 노트 검색**: meeting_id로 필터링 → 각 컬렉션에서 3개씩
- **전체 노트 검색**:
  1. 넉넉하게 k=30 검색
  2. Python에서 accessible_meeting_ids로 필터링
  3. 상위 3개씩 선택

```python
def search_documents(self, query, meeting_id=None, accessible_meeting_ids=None):
    if accessible_meeting_ids:
        # 전체 노트 검색
        chunk_result = self.vdb_manager.search(
            db_type="chunks",
            query=query,
            k=len(accessible_meeting_ids) * 10
        )

        # 권한 필터링
        chunks = [doc for doc in chunk_result
                 if doc.metadata.get('meeting_id') in accessible_meeting_ids]

        # 상위 3개
        chunks = chunks[:3]

        # subtopic도 동일
        ...
    else:
        # 단일 노트 검색
        chunks = self.vdb_manager.search(
            "chunks",
            query,
            k=3,
            filter_criteria={"meeting_id": meeting_id} if meeting_id else None
        )

        subtopics = self.vdb_manager.search(
            "subtopic",
            query,
            k=3,
            filter_criteria={"meeting_id": meeting_id} if meeting_id else None
        )

    return {
        "chunks": chunks,
        "subtopics": subtopics,
        "total_count": len(chunks) + len(subtopics)
    }
```

---

### 11.3 답변 생성 (utils/chat_manager.py:254-317)

**핵심 프롬프트**:
```python
prompt = f"""
당신은 회의록 내용을 바탕으로 질문에 답변하는 전문 비서 챗봇입니다.

[핵심 지침]
1. **반드시** 아래 [검색된 회의록 내용] **안에서만** 정보를 찾아서 답변
2. 정보가 없다면 "해당 내용을 회의록에서 찾을 수 없습니다."
3. 절대로 사전 지식이나 외부 정보 사용 금지
4. 답변은 명확하고 간결하게
5. **중요**: 회의 제목과 날짜는 메타데이터 참조 (본문 무시)

[검색된 회의록 내용]:
{context}

[사용자 질문]:
{query}

[답변]:
"""
```

**할루시네이션 방지 전략**:
1. "반드시 검색 결과 안에서만" 강조
2. 정보 없으면 솔직히 "모른다" 답변
3. 외부 지식 사용 명시적 금지
4. 메타데이터 우선 참조 (본문의 잘못된 날짜 무시)

---

## 12. 사용자 권한 관리

### 12.1 접근 권한 체크 (utils/user_manager.py:137-165)

```python
def can_access_meeting(user_id, meeting_id):
    """
    접근 가능 조건:
    1. 본인 소유 (owner_id == user_id)
    2. 공유받음 (meeting_shares에 존재)
    3. 관리자 (ADMIN_EMAILS)
    """
    with db._get_connection() as conn:
        # 1. 소유자 확인
        meeting = conn.execute(
            "SELECT owner_id FROM meetings WHERE id = ?",
            (meeting_id,)
        ).fetchone()

        if meeting and meeting['owner_id'] == user_id:
            return True

        # 2. 공유 확인
        share = conn.execute("""
            SELECT 1 FROM meeting_shares
            WHERE meeting_id = ? AND shared_with_user_id = ?
        """, (meeting_id, user_id)).fetchone()

        if share:
            return True

        # 3. 관리자 확인
        if is_admin(user_id):
            return True

    return False
```

---

### 12.2 접근 가능 회의 조회 (utils/user_manager.py:401-437)

```python
def get_user_accessible_meeting_ids(user_id):
    """
    사용자가 접근 가능한 모든 meeting_id 목록

    Returns:
        ["uuid1", "uuid2", "uuid3"]
    """
    with db._get_connection() as conn:
        # 1. 본인 소유
        owned = conn.execute(
            "SELECT id FROM meetings WHERE owner_id = ?",
            (user_id,)
        ).fetchall()

        # 2. 공유받음
        shared = conn.execute("""
            SELECT meeting_id FROM meeting_shares
            WHERE shared_with_user_id = ?
        """, (user_id,)).fetchall()

        # 3. 합치기
        meeting_ids = [row['id'] for row in owned]
        meeting_ids += [row['meeting_id'] for row in shared]

        return list(set(meeting_ids))  # 중복 제거
```

---

### 12.3 회의록 공유 (utils/user_manager.py:506-569)

```python
def share_meeting(meeting_id, owner_id, target_email, permission='read'):
    """
    회의록 공유

    Args:
        meeting_id: 공유할 회의
        owner_id: 공유하는 사람
        target_email: 공유받을 사람 이메일
        permission: 'read', 'write', 'admin'
    """
    # 1. 권한 체크
    if not can_edit_meeting(owner_id, meeting_id):
        raise PermissionError("공유 권한 없음")

    # 2. 대상 사용자 조회
    with db._get_connection() as conn:
        target_user = conn.execute(
            "SELECT id FROM users WHERE email = ?",
            (target_email,)
        ).fetchone()

        if not target_user:
            raise ValueError("사용자를 찾을 수 없습니다")

        # 3. 공유 등록
        conn.execute("""
            INSERT OR IGNORE INTO meeting_shares
            (meeting_id, shared_with_user_id, permission)
            VALUES (?, ?, ?)
        """, (meeting_id, target_user['id'], permission))
        conn.commit()
```

---

# 4부. API 엔드포인트

## 13. 인증 API

### GET /login
- **설명**: 로그인 페이지 렌더링
- **인증**: 불필요
- **반환**: HTML 템플릿

### POST /api/login
- **설명**: Firebase ID 토큰 검증 및 세션 생성
- **인증**: 불필요
- **Request Body**:
```json
{
    "idToken": "Firebase_ID_Token"
}
```
- **Response**:
```json
{
    "success": true,
    "user": {
        "uid": "firebase_uid",
        "email": "user@example.com",
        "displayName": "홍길동"
    }
}
```

### GET /logout
- **설명**: 세션 삭제 및 로그인 페이지로 리디렉션
- **인증**: 필요

---

## 14. 파일 업로드 API

### POST /api/upload
- **설명**: 파일 업로드 및 전체 파이프라인 실행
- **인증**: 필요 (@login_required)
- **Request** (FormData):
```
title: "1차회의"
meeting_date: "2025-11-10"
audio_file: File (wav, mp3, m4a, flac, mp4)
```
- **Response**:
```json
{
    "success": true,
    "meeting_id": "uuid",
    "redirect_url": "/viewer/uuid"
}
```
- **에러**:
```json
{
    "success": false,
    "error": "제목은 1~100자 이내여야 합니다"
}
```

### POST /api/upload_with_progress
- **설명**: SSE로 실시간 진행률 전송
- **인증**: 필요
- **Response** (text/event-stream):
```
data: {"progress": 20, "message": "파일 저장 완료"}

data: {"progress": 40, "message": "음성 인식 중..."}

data: {"progress": 100, "message": "완료!"}
```

### POST /api/script
- **설명**: 텍스트 직접 입력 (STT 생략)
- **인증**: 필요
- **Request**:
```json
{
    "title": "1차회의",
    "meeting_date": "2025-11-10",
    "script_text": "화자1: 안녕하세요\n화자2: 반갑습니다"
}
```

---

## 15. 회의록 CRUD API

### GET /api/meeting/<meeting_id>
- **설명**: 회의 정보 조회
- **인증**: 필요 (권한 체크)
- **Response**:
```json
{
    "id": "uuid",
    "title": "1차회의",
    "meeting_date": "2025-11-10",
    "audio_file": "uuid_audio.mp3",
    "owner_id": 1,
    "created_at": "2025-11-10 10:00:00"
}
```

### POST /api/update_title/<meeting_id>
- **설명**: 회의 제목 수정
- **인증**: 필요 (소유자 or 관리자)
- **Request**:
```json
{
    "new_title": "수정된 제목"
}
```
- **Response**:
```json
{
    "success": true,
    "message": "제목이 수정되었습니다"
}
```

### POST /api/delete_meeting/<meeting_id>
- **설명**: 회의 전체 삭제 (Cascade)
- **인증**: 필요 (소유자 or 관리자)
- **Response**:
```json
{
    "success": true,
    "message": "회의 데이터가 삭제되었습니다",
    "deleted": {
        "sqlite_dialogues": 50,
        "sqlite_minutes": 1,
        "sqlite_shares": 2,
        "vector_chunks": 15,
        "vector_subtopic": 5,
        "audio_file": "uuid_audio.mp3"
    }
}
```

---

## 16. 챗봇 API

### POST /api/chat
- **설명**: RAG 챗봇 질의
- **인증**: 필요
- **Request**:
```json
{
    "query": "다음 회의 일정은?",
    "meeting_id": "uuid"  // optional (null이면 전체 검색)
}
```
- **Response**:
```json
{
    "success": true,
    "answer": "11월 15일입니다.",
    "sources": [
        {
            "type": "chunk",
            "meeting_id": "uuid",
            "title": "1차회의",
            "meeting_date": "2025-11-10",
            "start_time": 120,
            "end_time": 180
        },
        {
            "type": "subtopic",
            "meeting_id": "uuid",
            "meeting_title": "1차회의",
            "main_topic": "일정 논의"
        }
    ]
}
```
- **에러**:
```json
{
    "success": false,
    "error": "접근 권한이 없습니다"
}
```

---

## 17. 공유 API

### POST /api/share/<meeting_id>
- **설명**: 회의록 공유
- **인증**: 필요 (소유자 or Admin)
- **Request**:
```json
{
    "email": "friend@example.com",
    "permission": "read"  // "read", "write", "admin"
}
```
- **Response**:
```json
{
    "success": true,
    "message": "회의록이 공유되었습니다"
}
```

### POST /api/unshare/<meeting_id>/<user_id>
- **설명**: 공유 취소
- **인증**: 필요 (소유자 or Admin)
- **Response**:
```json
{
    "success": true,
    "message": "공유가 취소되었습니다"
}
```

### GET /api/shared_users/<meeting_id>
- **설명**: 공유받은 사용자 목록
- **인증**: 필요 (소유자 or Admin)
- **Response**:
```json
{
    "success": true,
    "shared_users": [
        {
            "user_id": 2,
            "email": "friend@example.com",
            "display_name": "김철수",
            "permission": "read",
            "shared_at": "2025-11-10 15:00:00"
        }
    ]
}
```

---

# 5부. 실전 가이드

## 18. 회의록 생성 프로세스

### 단계별 흐름

**[1단계] 파일 업로드 (app.py:392)**
- 프론트엔드에서 FormData 전송
- 제목, 날짜, 오디오 파일

**[2단계] 검증 및 저장**
- 제목 검증: 1~100자, 특수문자 제한
- 날짜 파싱: ISO 8601 형식
- 파일명 생성: UUID + 원본 파일명
- uploads/ 폴더에 저장

**[3단계] MP4 변환 (필요시)**
- ffmpeg로 MP4 → WAV 변환
- 오디오 트랙만 추출

**[4단계] STT 실행 (stt.py:29)**
- Gemini 2.5 Pro API 호출
- 프롬프트 + 오디오 바이너리 전송
- JSON 응답 파싱
- start_time 정규화 (MM:SS → 초)

**[5단계] SQLite 저장 (db_manager.py)**
```python
# meetings 테이블
meeting_id = str(uuid.uuid4())
db.save_meeting_info(meeting_id, title, meeting_date, audio_file, owner_id)

# meeting_dialogues 테이블
for seg in segments:
    db.save_segment(
        meeting_id,
        seg['speaker_label'],
        seg['start_time'],
        seg['segment'],
        seg['confidence']
    )
```

**[6단계] 스마트 청킹 (vector_db_manager.py:116)**
```python
# 화자/시간/크기 고려하여 청킹
chunks = vdb_manager._create_smart_chunks(
    segments,
    max_chunk_size=1000,
    time_gap_threshold=60
)

# 텍스트 정제 (정규표현식으로 [Speaker X, MM:SS] 제거)
for chunk in chunks:
    chunk['text'] = vdb_manager._clean_text(chunk['text'])

# ChromaDB 저장
vdb_manager.add_meeting_as_chunk(meeting_id, title, meeting_date, audio_file, segments)
```

**[7단계] 요약 생성 (stt.py:154)**
```python
# 전체 대화 텍스트 생성
transcript = "\n".join([f"Speaker {s['speaker_label']}: {s['segment']}" for s in segments])

# Gemini Flash로 요약
summary = stt_manager.subtopic_generate(title, transcript)
```

**[8단계] ChromaDB 요약 저장 (vector_db_manager.py:313)**
```python
# ### 제목으로 분리
subtopics = summary.split('\n### ')

# 각 주제별로 저장
vdb_manager.add_summary_as_subtopic(meeting_id, title, meeting_date, audio_file, summary)
```

**[9단계] 마인드맵 생성 (stt.py:432)**
```python
# Gemini Flash로 마인드맵
mindmap = stt_manager.extract_mindmap_keywords(summary, title)
```

**[10단계] 회의록 저장 (db_manager.py)**
```python
# meeting_minutes 테이블
db.save_minutes(meeting_id, title, meeting_date, minutes_content=summary, mindmap_content=mindmap)
```

**[11단계] 응답**
```json
{
    "success": true,
    "meeting_id": "uuid",
    "redirect_url": "/viewer/uuid"
}
```

### 소요 시간 (30분 회의 기준)
- STT: 2-3분
- 청킹 & 임베딩: 30초
- 요약: 30초
- 마인드맵: 20초
- **총 약 4분**

---

## 19. 챗봇 질의 프로세스

### 단계별 흐름

**[1단계] 질문 수신 (app.py:1112)**
```python
data = request.get_json()
query = data.get("query")           # "다음 회의 일정은?"
meeting_id = data.get("meeting_id")  # null or "uuid"
```

**[2단계] 권한 체크**
```python
if meeting_id:
    # 단일 노트: 접근 권한 체크
    if not can_access_meeting(user_id, meeting_id):
        return jsonify({"error": "접근 권한 없음"}), 403
    accessible_meeting_ids = None
else:
    # 전체 노트: 접근 가능 목록 조회
    accessible_meeting_ids = get_user_accessible_meeting_ids(user_id)
```

**[3단계] ChatManager 호출**
```python
result = chat_manager.process_query(query, meeting_id, accessible_meeting_ids)
```

**[4단계] 문서 검색 (chat_manager.py:39)**

**(4-1) 쿼리 임베딩**
- OpenAI text-embedding-3-small
- "다음 회의 일정은?" → [0.2, 0.8, -0.3, ...] (1536차원)

**(4-2) meeting_chunks 검색**
```python
if accessible_meeting_ids:
    # 전체 노트 검색
    chunk_result = vdb_manager.search(
        db_type="chunks",
        query=query,
        k=30  # 넉넉하게
    )

    # Python에서 필터링
    chunks = [doc for doc in chunk_result
             if doc.metadata['meeting_id'] in accessible_meeting_ids]

    # 상위 3개
    chunks = chunks[:3]
else:
    # 단일 노트 검색
    chunks = vdb_manager.search(
        "chunks",
        query,
        k=3,
        filter_criteria={"meeting_id": meeting_id}
    )
```

**(4-3) meeting_subtopic 검색**
- chunks와 동일한 방식
- 상위 3개 선택

**[5단계] 컨텍스트 포맷팅 (chat_manager.py:206)**
```python
context = """
=== 회의 대화 내용 ===
[문서 1]
회의: 1차회의
일시: 2025-11-10
시간: 120초 - 180초
내용:
다음 회의는 15일로 결정되었습니다.

=== 회의 주제별 요약 ===
[요약 1]
회의: 1차회의
주제: 일정 논의
내용:
### 일정 논의
* 다음 회의 15일 확정
"""
```

**[6단계] Gemini 답변 생성 (chat_manager.py:254)**
```python
prompt = f"""
당신은 회의록 챗봇입니다.

[지침]
1. 반드시 아래 내용 안에서만 답변
2. 정보 없으면 "찾을 수 없습니다"
3. 외부 지식 사용 금지

[검색된 회의록 내용]:
{context}

[사용자 질문]:
{query}

[답변]:
"""

response = gemini_client.models.generate_content(
    model="gemini-2.5-flash",
    contents=prompt
)

answer = response.text.strip()
```

**[7단계] 출처 정보 추가**
```python
sources = []
for doc in chunks:
    sources.append({
        "type": "chunk",
        "meeting_id": doc.metadata['meeting_id'],
        "title": doc.metadata['title'],
        "start_time": doc.metadata['start_time']
    })
```

**[8단계] 응답**
```json
{
    "success": true,
    "answer": "11월 15일입니다.",
    "sources": [...]
}
```

### 소요 시간
- 임베딩: 0.5초
- 벡터 검색: 0.5초
- Gemini 답변: 2.5초
- 기타: 0.27초
- **총 약 3.77초**

---

## 20. 회의록 삭제 프로세스

### 단계별 흐름

**[1단계] 삭제 요청 (app.py:1086)**
```python
meeting_id = "uuid"
user_id = session['user_id']
```

**[2단계] 권한 체크**
```python
if not can_access_meeting(user_id, meeting_id):
    return jsonify({"error": "권한 없음"}), 403
```

**[3단계] VectorDBManager 통합 삭제**
```python
result = vdb_manager.delete_from_collection(db_type="all", meeting_id=meeting_id)
```

**[4단계] ChromaDB 삭제 (vector_db_manager.py:658)**

**(4-1) meeting_chunks 삭제**
```python
collection = client.get_collection("meeting_chunks")

# meeting_id로 조회
results = collection.get(where={"meeting_id": meeting_id})

# 삭제
if results['ids']:
    collection.delete(ids=results['ids'])
    print(f"✅ chunks: {len(results['ids'])}개 삭제")
```

**(4-2) meeting_subtopic 삭제**
- chunks와 동일한 방식

**[5단계] SQLite 삭제 (db_manager.py)**
```python
# audio_file 경로 조회
meeting = conn.execute(
    "SELECT audio_file FROM meetings WHERE id = ?",
    (meeting_id,)
).fetchone()

audio_file = meeting['audio_file'] if meeting else None

# meetings 삭제 (FK CASCADE)
conn.execute("DELETE FROM meetings WHERE id = ?", (meeting_id,))
conn.commit()

# Cascade로 자동 삭제:
# - meeting_dialogues
# - meeting_minutes
# - meeting_shares
```

**[6단계] 오디오 파일 삭제**
```python
if audio_file:
    file_path = os.path.join(UPLOAD_FOLDER, audio_file)
    if os.path.exists(file_path):
        os.remove(file_path)
```

**[7단계] 응답**
```json
{
    "success": true,
    "message": "회의 데이터가 삭제되었습니다",
    "deleted": {
        "sqlite_dialogues": 50,
        "sqlite_minutes": 1,
        "sqlite_shares": 2,
        "vector_chunks": 15,
        "vector_subtopic": 5,
        "audio_file": "uuid_audio.mp3"
    }
}
```

---

# 6부. 최적화 & 보안

## 21. 데이터베이스 최적화

### 21.1 인덱스 전략

**필수 인덱스**:
```sql
-- 회의 조회 최적화
CREATE INDEX idx_meetings_owner ON meetings(owner_id);
CREATE INDEX idx_meetings_date ON meetings(meeting_date DESC);

-- 대화 조회 최적화
CREATE INDEX idx_dialogues_meeting ON meeting_dialogues(meeting_id);
CREATE INDEX idx_dialogues_time ON meeting_dialogues(start_time);

-- 공유 확인 최적화
CREATE INDEX idx_shares_user ON meeting_shares(shared_with_user_id);
```

**복합 인덱스** (향후 추가 고려):
```sql
-- 공유 권한 체크 최적화
CREATE INDEX idx_shares_meeting_user ON meeting_shares(meeting_id, shared_with_user_id);
```

---

### 21.2 쿼리 최적화

**나쁜 예**:
```python
# Python에서 필터링 (비효율적)
meetings = db.execute("SELECT * FROM meetings")
my_meetings = [m for m in meetings if m['owner_id'] == user_id]
```

**좋은 예**:
```python
# DB에서 필터링 (효율적)
my_meetings = db.execute(
    "SELECT * FROM meetings WHERE owner_id = ? ORDER BY meeting_date DESC",
    (user_id,)
)
```

---

### 21.3 ChromaDB 최적화

**배치 임베딩**:
```python
# 나쁜 예: 하나씩 임베딩
for chunk in chunks:
    embedding = embeddings.embed_query(chunk['text'])

# 좋은 예: 배치로 임베딩 (10배 빠름)
texts = [chunk['text'] for chunk in chunks]
embeddings_list = embeddings.embed_documents(texts)
```

**메타데이터 필터링 활용**:
```python
# 나쁜 예: 전체 검색 후 Python 필터링
results = vdb.search(query, k=100)
filtered = [r for r in results if r.metadata['meeting_id'] in accessible_ids]

# 좋은 예: DB 레벨 필터링
results = vdb.search(
    query,
    k=10,
    filter_criteria={"meeting_id": {"$in": accessible_ids}}
)
```

---

## 22. 보안 Best Practice

### 22.1 파일 업로드 보안

**1. 확장자 화이트리스트**:
```python
ALLOWED_EXTENSIONS = {"wav", "mp3", "m4a", "flac", "mp4"}

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
```

**2. 파일 크기 제한**:
```python
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB
```

**3. 파일명 안전화**:
```python
from werkzeug.utils import secure_filename

filename = secure_filename(file.filename)
unique_filename = f"{uuid.uuid4().hex}_{filename}"
```

**4. MIME 타입 검증** (향후 추가):
```python
import magic

mime = magic.Magic(mime=True)
file_mime = mime.from_buffer(file.read(1024))

if file_mime not in ["audio/wav", "audio/mpeg", "audio/mp4"]:
    raise ValueError("Invalid file type")
```

---

### 22.2 SQL Injection 방지

**나쁜 예**:
```python
# String formatting (위험!)
query = f"SELECT * FROM meetings WHERE id = '{meeting_id}'"
db.execute(query)
```

**좋은 예**:
```python
# Parameterized Query (안전)
query = "SELECT * FROM meetings WHERE id = ?"
db.execute(query, (meeting_id,))
```

---

### 22.3 XSS 방지

**Jinja2 자동 이스케이프** (Flask 기본):
```html
<!-- 자동으로 HTML escape -->
<h1>{{ user_input }}</h1>
```

**마크다운 Sanitize**:
```python
import bleach

# 허용 태그만 남기기
safe_html = bleach.clean(
    markdown_html,
    tags=['p', 'h1', 'h2', 'h3', 'ul', 'li', 'strong', 'em', 'code', 'pre'],
    attributes={'a': ['href', 'title']}
)
```

---

### 22.4 인증 보안

**세션 설정**:
```python
app.config['SESSION_COOKIE_SECURE'] = True      # HTTPS only
app.config['SESSION_COOKIE_HTTPONLY'] = True    # JavaScript 접근 차단
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # CSRF 방지
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7)
```

**Firebase ID 토큰 검증**:
```python
from firebase_admin import auth

def verify_firebase_token(id_token):
    try:
        decoded_token = auth.verify_id_token(id_token)
        return decoded_token
    except Exception as e:
        return None
```

---

## 23. 에러 핸들링

### 23.1 전역 에러 핸들러

```python
@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(403)
def forbidden(error):
    return jsonify({"error": "Access denied"}), 403

@app.errorhandler(500)
def internal_error(error):
    app.logger.error(f"Internal error: {error}")
    return jsonify({"error": "Internal server error"}), 500

@app.errorhandler(Exception)
def handle_exception(e):
    app.logger.error(f"Unhandled exception: {e}", exc_info=True)
    return jsonify({"error": "An unexpected error occurred"}), 500
```

---

### 23.2 재시도 로직

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
def transcribe_audio(audio_path):
    """
    최대 3회 재시도 (지수 백오프)
    실패 시: 4초, 8초, 10초 대기
    """
    return gemini_api_call(audio_path)
```

---

### 23.3 로깅

```python
import logging

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 사용 예시
@app.route("/api/upload")
def upload():
    logger.info(f"User {user_id} uploading file: {filename}")
    try:
        # 파일 처리
        logger.info(f"Upload successful: {meeting_id}")
    except Exception as e:
        logger.error(f"Upload failed: {e}", exc_info=True)
```

---

### 23.4 성능 모니터링

```python
import time
from functools import wraps

def timing_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        logger.info(f"{func.__name__} took {end - start:.2f}s")
        return result
    return wrapper

@timing_decorator
def transcribe_audio(audio_path):
    # 실행 시간 자동 로깅
    pass
```

---

# 부록

## 주요 파일 참조표

| 파일 | 핵심 라인 | 설명 |
|------|----------|------|
| app.py | 392-554 | 파일 업로드 & 파이프라인 |
| app.py | 1112-1165 | 챗봇 API |
| utils/stt.py | 29-152 | Gemini STT |
| utils/stt.py | 154-271 | 요약 생성 |
| utils/stt.py | 432-526 | 마인드맵 생성 |
| utils/db_manager.py | 전체 | SQLite CRUD |
| utils/vector_db_manager.py | 116-171 | 청킹 & 저장 |
| utils/vector_db_manager.py | 230-310 | 스마트 청킹 알고리즘 |
| utils/vector_db_manager.py | 368-483 | 벡터 검색 |
| utils/chat_manager.py | 319-387 | RAG 파이프라인 |
| utils/user_manager.py | 137-165 | 권한 체크 |

---

## 핵심 개념 요약

### 1. 데이터 흐름
```
파일 업로드 → STT → SQLite + ChromaDB → 요약/마인드맵 → 완료
```

### 2. RAG 파이프라인
```
질문 → 임베딩 → 벡터 검색 (chunks + subtopics) → 컨텍스트 → Gemini → 답변
```

### 3. 권한 체계
```
본인 소유 OR 공유받음 OR 관리자 = 접근 허용
```

### 4. 데이터베이스
- **SQLite**: 메타데이터 (관계형)
  - users, meetings, meeting_dialogues, meeting_minutes, meeting_shares
- **ChromaDB**: 실제 내용 (벡터 검색)
  - meeting_chunks, meeting_subtopic

### 5. AI 역할
- **Gemini 2.5 Pro**: STT (화자 분리)
- **Gemini 2.5 Flash**: 요약, 마인드맵, 챗봇 답변
- **OpenAI text-embedding-3-small**: 임베딩 (1536차원)

---

**작성일**: 2025-11-11
**버전**: 인쇄용 v1.0
**대상**: 백엔드 개발자, 시스템 아키텍트
**페이지 수**: 약 40페이지

이 문서 하나면 백엔드 시스템 전체를 완벽히 이해하고 수정/확장할 수 있습니다!
