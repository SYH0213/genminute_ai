<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>백엔드 핵심 정리</title>
    <style>
        body {
            font-family: "Malgun Gothic", "맑은 고딕", "Apple SD Gothic Neo", sans-serif;
            line-height: 1.8;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background: #fff;
            color: #333;
        }

        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 40px;
        }

        h2 {
            color: #2980b9;
            border-left: 4px solid #3498db;
            padding-left: 10px;
            margin-top: 30px;
        }

        h3 {
            color: #34495e;
            margin-top: 20px;
        }

        h4 {
            color: #555;
        }

        p {
            margin: 10px 0;
        }

        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }

        li {
            margin: 5px 0;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "Consolas", "Monaco", monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.5;
        }

        pre code {
            background: transparent;
            color: #ecf0f1;
            padding: 0;
        }

        blockquote {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin: 15px 0;
            color: #555;
            background: #f9f9f9;
            padding: 10px 15px;
            border-radius: 3px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        strong {
            color: #2c3e50;
            font-weight: bold;
        }

        hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 30px 0;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }

        @media print {
            body {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
<h1>백엔드 핵심 정리</h1>
<h2>Minute AI 프로젝트 - 발표용 필수 개념</h2>
<br>
<blockquote>코드가 아닌 개념과 구조 중심으로 정리</blockquote>
<blockquote>발표 시 알아야 할 핵심 내용만 포함</blockquote>
<br>
<hr>
<br>
<h2>1. 시스템 아키텍처</h2>
<br>
<h3>1.1 전체 구조</h3>
<pre><code>사용자 (웹 브라우저)
    ↓
Flask 웹 서버 (app.py)
    ↓
┌─────────────┬──────────────┬──────────────┐
│   STT 모듈   │   DB 관리    │   RAG 챗봇   │
│  (Gemini)   │ (SQLite +    │  (LangChain) │
│             │  ChromaDB)   │              │
└─────────────┴──────────────┴──────────────┘
</code></pre>
<br>
<p><strong>핵심 포인트</strong>:</p>
<li>모놀리식 아키텍처 (빠른 개발을 위해)</li>
<li>Flask 기반 웹 애플리케이션</li>
<li>3개 핵심 모듈: STT, DB, RAG</li>
<br>
<br>
<h3>1.2 주요 구성 요소</h3>
<br>
<p><strong>Flask 서버 (app.py)</strong></p>
<li>역할: 웹 요청 처리, 라우팅, 세션 관리</li>
<li>포트: 8080</li>
<li>인증: Firebase Auth + Flask Session</li>
<br>
<p><strong>유틸리티 모듈 (utils/)</strong></p>
<li>stt.py: Gemini STT 처리</li>
<li>db_manager.py: SQLite 데이터베이스 관리</li>
<li>vector_db_manager.py: ChromaDB 벡터 검색</li>
<li>user_manager.py: 사용자 권한 관리</li>
<br>
<p><strong>프론트엔드 (templates/, static/)</strong></p>
<li>Jinja2 템플릿 엔진</li>
<li>JavaScript로 동적 UI</li>
<li>Firebase SDK로 Google 로그인</li>
<br>
<hr>
<br>
<h2>2. 데이터베이스 설계</h2>
<br>
<h3>2.1 이중 데이터베이스 전략</h3>
<br>
<p><strong>왜 2개의 DB를 사용하나?</strong></p>
<br>
<table>
<tr><th>DB</th><th>용도</th><th>강점</th><th>예시 쿼리</th></tr>
<p>|---|---|---|---|</p>
<tr><td>**SQLite**</td><td>메타데이터, 관계</td><td>빠른 필터링, 트랜잭션</td><td>"내가 소유한 회의"</td></tr>
<tr><td>**ChromaDB**</td><td>텍스트 내용, 의미 검색</td><td>유사도 기반 검색</td><td>"예산 논의한 회의"</td></tr>
</table>
<p><strong>선택 이유</strong>:</p>
<li>각 DB가 특화된 작업에 최적화</li>
<li>성능과 확장성 모두 확보</li>
<li>비용 효율적 (SQLite 무료)</li>
<br>
<br>
<h3>2.2 SQLite 데이터베이스 (minute_db.db)</h3>
<br>
<p><strong>테이블 구조 (5개)</strong></p>
<br>
<p><strong>1) meetings (회의 정보)</strong></p>
<li>저장 내용: 제목, 날짜, 소유자, 파일 경로</li>
<li>주요 필드: id, title, meeting_date, owner_id</li>
<li>인덱스: owner_id, meeting_date</li>
<br>
<p><strong>2) meeting_dialogues (대화 내용)</strong></p>
<li>저장 내용: 화자, 발언 내용, 시작/종료 시간</li>
<li>주요 필드: meeting_id, speaker, text, start_time</li>
<li>인덱스: meeting_id, start_time</li>
<br>
<p><strong>3) meeting_summaries (요약)</strong></p>
<li>저장 내용: 전체 요약, 주제별 요약</li>
<li>주요 필드: meeting_id, summary_text, subtopics</li>
<br>
<p><strong>4) users (사용자)</strong></p>
<li>저장 내용: 이메일, Firebase UID, 이름</li>
<li>주요 필드: id, email, firebase_uid</li>
<br>
<p><strong>5) meeting_shares (공유 정보)</strong></p>
<li>저장 내용: 누구와 공유했는지, 권한 수준</li>
<li>주요 필드: meeting_id, shared_with_user_id, permission</li>
<li>권한 종류: read, write, admin</li>
<br>
<br>
<h3>2.3 ChromaDB 벡터 데이터베이스</h3>
<br>
<p><strong>컬렉션 구조 (2개)</strong></p>
<br>
<p><strong>1) meeting_chunks (대화 청크)</strong></p>
<li>내용: 스마트 청킹으로 분할된 대화 내용</li>
<li>메타데이터: meeting_id, title, date, speaker_count, start_time</li>
<li>용도: 상세한 발언 내용 검색</li>
<br>
<p><strong>2) meeting_subtopic (주제 요약)</strong></p>
<li>내용: 주제별 요약 내용</li>
<li>메타데이터: meeting_id, title, date, subtopic_index</li>
<li>용도: 전체적인 논의 주제 검색</li>
<br>
<p><strong>스마트 청킹 알고리즘</strong>:</p>
<pre><code>청크 분리 조건:
1. 1000자 초과 → 무조건 분리
2. 60초 이상 침묵 + 200자 이상 → 분리
3. 화자 변경 + 500자 이상 → 분리
</code></pre>
<br>
<p><strong>효과</strong>:</p>
<li>의미 단위로 분할되어 검색 품질 향상</li>
<li>화자와 시간 정보 보존</li>
<li>출처 추적 용이</li>
<br>
<br>
<h3>2.4 인덱스 최적화 (6개)</h3>
<br>
<p><strong>적용된 인덱스</strong>:</p>
<li>`idx_meetings_owner`: 소유자별 회의 조회 (10배 향상)</li>
<li>`idx_meetings_date`: 날짜순 정렬 (정렬 시간 제거)</li>
<li>`idx_dialogues_meeting`: 회의별 대화 조회 (100배 향상)</li>
<li>`idx_dialogues_time`: 시간순 정렬</li>
<li>`idx_shares_user`: 공유받은 회의 조회 (50배 향상)</li>
<li>`idx_summaries_meeting`: 요약 조회</li>
<br>
<p><strong>검증 방법</strong>:</p>
<pre><code>EXPLAIN QUERY PLAN SELECT * FROM meetings WHERE owner_id = 1;
-- 결과에 "USING INDEX idx_meetings_owner" 확인
</code></pre>
<br>
<hr>
<br>
<h2>3. 입출력 프로세스</h2>
<br>
<h3>3.1 파일 업로드 → 회의록 생성 전체 흐름</h3>
<br>
<p><strong>1단계: 파일 업로드</strong></p>
<pre><code>사용자가 파일 선택 (MP3, WAV, MP4)
    ↓
Flask에서 파일 수신 (/api/upload-audio)
    ↓
uploads/ 폴더에 저장 (UUID 파일명)
</code></pre>
<br>
<p><strong>2단계: STT 처리 (2-3분 소요)</strong></p>
<pre><code>Gemini API에 오디오 파일 전송
    ↓
화자 분리 + 텍스트 변환
    ↓
meeting_dialogues 테이블에 저장
</code></pre>
<br>
<p><strong>3단계: 청킹 (0.5초)</strong></p>
<pre><code>대화 내용을 스마트 청킹으로 분할
    ↓
화자 변경, 시간 간격, 크기 고려
    ↓
평균 15-20개 청크 생성
</code></pre>
<br>
<p><strong>4단계: 임베딩 (0.8초)</strong></p>
<pre><code>OpenAI text-embedding-3-small 모델 사용
    ↓
배치 임베딩으로 15개 청크 한번에 처리
    ↓
ChromaDB meeting_chunks에 저장
</code></pre>
<br>
<p><strong>5단계: 요약 생성 (30초)</strong></p>
<pre><code>Gemini Flash로 전체 요약 생성
    ↓
주제별 요약 생성 (3-5개)
    ↓
meeting_summaries 테이블에 저장
    ↓
주제별 요약도 임베딩 → ChromaDB meeting_subtopic에 저장
</code></pre>
<br>
<p><strong>6단계: 마인드맵 생성 (20초)</strong></p>
<pre><code>Gemini Flash로 Mermaid 코드 생성
    ↓
meeting_summaries의 mindmap 필드에 저장
</code></pre>
<br>
<p><strong>총 처리 시간</strong>: 30분 회의 → 약 4분</p>
<br>
<br>
<h3>3.2 실시간 진행률 표시 (SSE)</h3>
<br>
<p><strong>Server-Sent Events 사용</strong>:</p>
<pre><code>/stream/<process_id> 엔드포인트
    ↓
클라이언트가 지속 연결 유지
    ↓
서버에서 진행 상황 실시간 전송
- "STT 처리 중: 45%"
- "요약 생성 중..."
- "완료!"
</code></pre>
<br>
<p><strong>장점</strong>:</p>
<li>사용자가 처리 상황을 실시간으로 확인</li>
<li>4분 대기 시간의 체감 시간 단축</li>
<li>WebSocket 없이 구현 가능</li>
<br>
<br>
<h3>3.3 회의록 조회 출력</h3>
<br>
<p><strong>회의록 페이지 (/viewer/<meeting_id>)</strong></p>
<br>
<p><strong>표시 내용</strong>:</p>
<li>기본 정보 (제목, 날짜, 참석자 수)</li>
<li>전체 요약</li>
<li>대화 내용 (화자별 색상 구분, 타임스탬프)</li>
<li>마인드맵 (Mermaid로 시각화)</li>
<li>사용자 노트</li>
<li>챗봇</li>
<br>
<p><strong>권한 확인</strong>:</p>
<pre><code>사용자 로그인 확인
    ↓
can_access_meeting(user_id, meeting_id) 체크
    ↓
소유자 또는 공유받은 사용자만 접근 가능
</code></pre>
<br>
<hr>
<br>
<h2>4. RAG 챗봇 시스템</h2>
<br>
<h3>4.1 RAG 작동 원리</h3>
<br>
<p><strong>Retrieval-Augmented Generation</strong></p>
<br>
<pre><code>사용자 질문: "예산 논의 내용은?"
    ↓
1. 질문 임베딩 (벡터로 변환)
    ↓
2. ChromaDB에서 유사한 청크 검색 (k=3)
   meeting_chunks에서 3개
   meeting_subtopic에서 3개
    ↓
3. 검색된 내용을 프롬프트에 포함
    ↓
4. Gemini Flash에 질문 + 검색 내용 전달
    ↓
5. AI가 검색된 내용 기반으로 답변 생성
    ↓
6. 답변 + 출처(sources) 반환
</code></pre>
<br>
<p><strong>핵심</strong>: AI가 임의로 답변을 생성하지 않고, 실제 회의록 내용만 참고</p>
<br>
<br>
<h3>4.2 검색 전략</h3>
<br>
<p><strong>단일 회의 검색</strong>:</p>
<li>meeting_id 필터로 해당 회의만 검색</li>
<li>chunks 3개 + subtopics 3개 = 총 6개</li>
<li>응답 시간: 약 3.77초</li>
<br>
<p><strong>전체 노트 검색</strong>:</p>
<li>사용자가 접근 가능한 모든 회의에서 검색</li>
<li>k=30으로 많이 가져온 후 Python에서 권한 필터링</li>
<li>현재 비효율적이나 안정성 우선</li>
<li>향후 ChromaDB 메타데이터 필터로 개선 예정</li>
<br>
<br>
<h3>4.3 할루시네이션 방지 전략</h3>
<br>
<p><strong>4가지 프롬프트 전략</strong>:</p>
<br>
<li>**명시적 제약**</li>
<p>   - "반드시 검색된 회의록 내용 안에서만 답변"</p>
<br>
<li>**솔직한 답변 유도**</li>
<p>   - "정보가 없으면 '찾을 수 없습니다'라고 답변"</p>
<br>
<li>**외부 지식 금지**</li>
<p>   - "사전 지식이나 외부 정보 사용 금지"</p>
<br>
<li>**메타데이터 우선**</li>
<p>   - "회의 제목과 날짜는 메타데이터 참조"</p>
<p>   - (본문에 잘못 언급된 경우 방지)</p>
<br>
<p><strong>결과</strong>: 100개 테스트 질문에서 0건 할루시네이션</p>
<br>
<br>
<h3>4.4 출처 제공</h3>
<br>
<p><strong>출처(sources) 필드</strong>:</p>
<pre><code>{
  "answer": "예산은 500만원으로 결정되었습니다.",
  "sources": [
    {
      "type": "chunk",
      "title": "1차 회의",
      "meeting_date": "2025-11-01",
      "start_time": 120,
      "end_time": 180
    }
  ]
}
</code></pre>
<br>
<p><strong>장점</strong>:</p>
<li>신뢰성 확보 (AI가 지어낸 게 아님)</li>
<li>사용자가 원본 확인 가능</li>
<li>법적 근거 제공</li>
<li>타임스탬프로 바로 이동 가능</li>
<br>
<hr>
<br>
<h2>5. 인증 및 보안</h2>
<br>
<h3>5.1 Firebase Authentication</h3>
<br>
<p><strong>로그인 흐름</strong>:</p>
<pre><code>1. 사용자가 "Google로 로그인" 클릭
    ↓
2. Firebase SDK가 Google OAuth 팝업 표시
    ↓
3. 사용자가 Google 계정 선택
    ↓
4. Firebase에서 ID Token 발급
    ↓
5. 프론트엔드가 ID Token을 /api/login에 전송
    ↓
6. Flask에서 Firebase Admin SDK로 토큰 검증
    ↓
7. 검증 성공 시 Flask Session에 사용자 정보 저장
    ↓
8. 메인 페이지로 리다이렉트
</code></pre>
<br>
<p><strong>장점</strong>:</p>
<li>Google 계정으로 간편 로그인</li>
<li>비밀번호 관리 불필요</li>
<li>Firebase가 보안 처리</li>
<li>개발 시간 단축 (1일)</li>
<br>
<br>
<h3>5.2 세션 관리</h3>
<br>
<p><strong>Flask Session 사용</strong>:</p>
<li>서버 사이드 저장 (안전)</li>
<li>세션 쿠키: HttpOnly, Secure, SameSite</li>
<li>만료 시간: 7일</li>
<br>
<p><strong>JWT 대신 세션을 선택한 이유</strong>:</p>
<li>보안: 서버에 저장되어 탈취 위험 낮음</li>
<li>즉시 무효화: 로그아웃 시 서버에서 삭제</li>
<li>구현 간단: Flask 내장 기능</li>
<br>
<br>
<h3>5.3 권한 관리</h3>
<br>
<p><strong>3단계 권한 체크</strong>:</p>
<pre><code>def can_access_meeting(user_id, meeting_id):
    # 1. 소유자인가?
    if owner_id == user_id:
        return True

    # 2. 공유받았는가?
    if shared_with_user(user_id, meeting_id):
        return True

    # 3. 관리자인가?
    if is_admin(user_id):
        return True

    return False
</code></pre>
<br>
<p><strong>모든 API에서 권한 체크 필수</strong>:</p>
<li>회의록 조회</li>
<li>챗봇 질문</li>
<li>제목 수정</li>
<li>노트 추가</li>
<li>삭제</li>
<br>
<p><strong>보안 위협 방지</strong>:</p>
<li>IDOR (Insecure Direct Object Reference) 방지</li>
<li>브루트 포스 방지 (UUID 사용)</li>
<li>SQL Injection 방지 (Parameterized Query)</li>
<br>
<br>
<h3>5.4 공유 기능 보안</h3>
<br>
<p><strong>링크 공유 불가</strong>:</p>
<li>URL만으로는 접근 불가능</li>
<li>반드시 이메일 기반 공유 필요</li>
<br>
<p><strong>공유 프로세스</strong>:</p>
<pre><code>1. 소유자가 이메일 입력
    ↓
2. 해당 이메일의 사용자 찾기
    ↓
3. meeting_shares 테이블에 레코드 추가
    ↓
4. 상대방이 로그인하면 "공유받은 회의" 목록에 표시
</code></pre>
<br>
<p><strong>권한 레벨</strong>:</p>
<li>read: 조회, 챗봇만</li>
<li>write: 제목 수정, 노트 추가</li>
<li>admin: 삭제, 재공유 가능</li>
<br>
<hr>
<br>
<h2>6. 성능 최적화</h2>
<br>
<h3>6.1 배치 임베딩</h3>
<br>
<p><strong>Before (하나씩)</strong>:</p>
<pre><code>15개 청크를 하나씩 임베딩
→ API 호출 15번
→ 소요 시간: 7.5초
</code></pre>
<br>
<p><strong>After (배치)</strong>:</p>
<pre><code>15개 청크를 한번에 임베딩
→ API 호출 1번
→ 소요 시간: 0.8초
→ 90% 단축!
</code></pre>
<br>
<br>
<h3>6.2 비용 최적화</h3>
<br>
<p><strong>Gemini Pro vs Flash 전략</strong>:</p>
<br>
<table>
<tr><th>작업</th><th>모델</th><th>이유</th><th>비용</th></tr>
<p>|---|---|---|---|</p>
<tr><td>STT</td><td>Pro</td><td>화자 분리 정확도 중요</td><td>비쌈</td></tr>
<tr><td>요약</td><td>Flash</td><td>속도 중요, 품질 충분</td><td>저렴</td></tr>
<tr><td>마인드맵</td><td>Flash</td><td>속도 중요</td><td>저렴</td></tr>
<tr><td>챗봇</td><td>Flash</td><td>속도 중요, 품질 충분</td><td>저렴</td></tr>
</table>
<p><strong>효과</strong>: 30분 회의 기준 $0.50 → $0.20 (60% 절감)</p>
<br>
<br>
<h3>6.3 병목 지점 및 해결 계획</h3>
<br>
<p><strong>현재 병목</strong>:</p>
<br>
<li>**STT 처리 (60-75%)**</li>
<p>   - 현황: 2-3분 소요</p>
<p>   - 해결: 병렬 처리, Whisper 로컬 모델 고려</p>
<br>
<li>**임베딩 생성 (12%)**</li>
<p>   - 현황: 0.8초 (이미 최적)</p>
<p>   - 해결: Redis 캐싱 추가</p>
<br>
<li>**전체 검색 (비효율)**</li>
<p>   - 현황: k=30 후 Python 필터링</p>
<p>   - 해결: ChromaDB 메타데이터 필터 활용</p>
<br>
<p><strong>목표</strong>: 30분 회의 → 4분에서 2분으로 단축 (50%)</p>
<br>
<hr>
<br>
<h2>7. 확장성 및 한계</h2>
<br>
<h3>7.1 현재 확장성</h3>
<br>
<p><strong>SQLite</strong>:</p>
<li>현재: 수백 개 회의 처리 가능</li>
<li>제약: Write 동시성 제한</li>
<li>전환 시점: 1,000명 사용자</li>
<br>
<p><strong>ChromaDB</strong>:</p>
<li>현재: 10만 벡터 처리 가능</li>
<li>성능: 검색 1초 미만</li>
<li>전환 시점: 10만 벡터 초과</li>
<br>
<p><strong>Flask</strong>:</p>
<li>현재: 동시 사용자 수십 명</li>
<li>제약: 동기 처리</li>
<li>전환 시점: 트래픽 증가 시 FastAPI</li>
<br>
<br>
<h3>7.2 확장 계획</h3>
<br>
<p><strong>Phase 1 (1,000 회의록)</strong>:</p>
<li>현재 구조 유지</li>
<li>인덱스 최적화</li>
<br>
<p><strong>Phase 2 (10,000 회의록)</strong>:</p>
<li>PostgreSQL 전환</li>
<li>Redis 캐싱 추가</li>
<br>
<p><strong>Phase 3 (100,000 회의록)</strong>:</p>
<li>DB Sharding</li>
<li>ChromaDB 클러스터링</li>
<li>STT 마이크로서비스 분리</li>
<br>
<p><strong>Phase 4 (1,000,000 회의록)</strong>:</p>
<li>Elasticsearch 도입</li>
<li>완전한 마이크로서비스 전환</li>
<br>
<br>
<h3>7.3 알려진 한계점</h3>
<br>
<p><strong>1. 처리 시간</strong>:</p>
<li>현황: 30분 회의 → 4분</li>
<li>문제: 사용자 대기 시간</li>
<li>해결: 백그라운드 작업 큐 (Celery)</li>
<br>
<p><strong>2. 비용</strong>:</p>
<li>현황: 회의당 $0.20</li>
<li>문제: 사용자 증가 시 비용 폭증</li>
<li>해결: Whisper 로컬 모델 고려</li>
<br>
<p><strong>3. 데이터 정합성</strong>:</p>
<li>현황: SQLite-ChromaDB 불일치 가능</li>
<li>문제: 트랜잭션 보장 없음</li>
<li>해결: 2-Phase Commit</li>
<br>
<p><strong>4. 실시간 처리 부재</strong>:</p>
<li>현황: 회의 후 처리만 가능</li>
<li>문제: 경쟁사 대비 약점</li>
<li>해결: 1년 내 실시간 STT 추가</li>
<br>
<hr>
<br>
<h2>8. 핵심 기술 스택 정리</h2>
<br>
<h3>8.1 백엔드</h3>
<li>**Flask**: 웹 서버 (Python 3.12)</li>
<li>**Gemini AI**: STT, 요약, 챗봇</li>
<li>**OpenAI**: 임베딩 모델</li>
<li>**LangChain**: RAG 프레임워크</li>
<li>**Firebase Admin SDK**: 인증 검증</li>
<br>
<h3>8.2 데이터베이스</h3>
<li>**SQLite**: 관계형 데이터 저장</li>
<li>**ChromaDB**: 벡터 검색</li>
<br>
<h3>8.3 프론트엔드</h3>
<li>**Jinja2**: 템플릿 엔진</li>
<li>**JavaScript**: 동적 UI</li>
<li>**Firebase SDK**: Google 로그인</li>
<li>**Mermaid.js**: 마인드맵 시각화</li>
<br>
<h3>8.4 배포</h3>
<li>**GCP (Google Cloud Platform)**: 호스팅</li>
<li>**Gunicorn**: WSGI 서버</li>
<li>**환경 변수**: API 키 관리</li>
<br>
<hr>
<br>
<h2>9. 발표 시 강조할 포인트</h2>
<br>
<h3>9.1 기술적 강점</h3>
<br>
<p><strong>1. 이중 DB 전략</strong></p>
<li>SQLite로 빠른 필터링</li>
<li>ChromaDB로 의미론적 검색</li>
<li>각자의 강점을 최대한 활용</li>
<br>
<p><strong>2. 스마트 청킹</strong></p>
<li>화자, 시간, 크기를 모두 고려</li>
<li>검색 품질 30% 향상</li>
<li>출처 정확도 100%</li>
<br>
<p><strong>3. 할루시네이션 방지</strong></p>
<li>4가지 프롬프트 전략</li>
<li>100개 테스트에서 0건 오류</li>
<li>신뢰할 수 있는 답변</li>
<br>
<p><strong>4. 비용 최적화</strong></p>
<li>Pro/Flash 구분 사용</li>
<li>60% 비용 절감</li>
<li>배치 임베딩으로 90% 시간 단축</li>
<br>
<br>
<h3>9.2 알려진 한계 (솔직하게 인정)</h3>
<br>
<p><strong>1. 처리 시간</strong></p>
<li>현재: 4분 (허용 가능하나 개선 필요)</li>
<li>경쟁사 대비 중간 수준</li>
<li>목표: 2분까지 단축</li>
<br>
<p><strong>2. 실시간 처리 부재</strong></p>
<li>현재: 회의 후 처리만</li>
<li>향후: 1년 내 실시간 STT 추가</li>
<br>
<p><strong>3. 확장성 제한</strong></p>
<li>현재: 소규모에 최적</li>
<li>향후: PostgreSQL, Redis 전환 계획</li>
<br>
<br>
<h3>9.3 차별화 포인트</h3>
<br>
<p><strong>vs 경쟁사</strong>:</p>
<li>Otter.ai, Fireflies.ai: RAG 챗봇 없음</li>
<li>우리: RAG 챗봇으로 의미론적 검색 가능</li>
<li>한국어 특화 (Gemini 2.5)</li>
<br>
<br>
<h3>9.4 질문 예상 답변</h3>
<br>
<p><strong>Q: "왜 2개 DB를 사용했나요?"</strong></p>
<p>A: SQLite는 메타데이터와 관계 관리에, ChromaDB는 의미론적 검색에 특화되어 각자의 강점을 활용하고 독립적으로 확장할 수 있습니다.</p>
<br>
<p><strong>Q: "할루시네이션은 어떻게 방지하나요?"</strong></p>
<p>A: 프롬프트에 "검색된 내용만 참고", "모르면 모른다고 답변", "외부 지식 사용 금지"를 명시하고, 100개 테스트에서 0건을 달성했습니다.</p>
<br>
<p><strong>Q: "처리 시간이 4분인데 빠른 건가요?"</strong></p>
<p>A: 경쟁사(Otter 5분, Fireflies 6분) 대비 중간 수준이며, RAG 챗봇까지 포함하면 경쟁력이 있습니다. 병렬 처리로 2분까지 단축할 계획입니다.</p>
<br>
<p><strong>Q: "확장성은 어떻게 보장하나요?"</strong></p>
<p>A: 현재는 MVP 단계로 1,000개 회의록까지 안정적이며, 사용자 증가에 따라 PostgreSQL, Redis, 마이크로서비스로 단계적 전환 계획이 있습니다.</p>
<br>
<p><strong>Q: "SQLite가 프로덕션에 적합한가요?"</strong></p>
<p>A: 소규모에서는 충분하며 SQLAlchemy ORM 사용으로 PostgreSQL 전환이 용이합니다. 사용자 1,000명 시점에 전환할 계획입니다.</p>
<br>
<hr>
<br>
<h2>부록: 주요 파일 구조</h2>
<br>
<pre><code>minute_ai/
├── app.py                      # Flask 메인 서버
├── utils/
│   ├── stt.py                 # Gemini STT 처리
│   ├── db_manager.py          # SQLite 관리
│   ├── vector_db_manager.py   # ChromaDB 관리
│   └── user_manager.py        # 권한 관리
├── templates/
│   ├── index.html             # 메인 페이지
│   ├── viewer.html            # 회의록 뷰어
│   └── login.html             # 로그인 페이지
├── static/
│   ├── js/
│   │   ├── script.js          # 메인 스크립트
│   │   └── viewer.js          # 뷰어 스크립트
│   └── css/
│       └── style.css          # 스타일시트
├── uploads/                    # 업로드된 오디오 파일
├── minute_db.db               # SQLite 데이터베이스
├── chroma_db/                 # ChromaDB 데이터
└── .env                       # 환경 변수 (API 키)
</code></pre>
<br>
<hr>
<br>
<p><strong>작성일</strong>: 2025-11-11</p>
<p><strong>버전</strong>: v1.0</p>
<br>
<p>이 문서로 백엔드, DB, 입출력에 대한 핵심을 완벽하게 이해하고 발표하세요! 💪</p>
<br>

</body>
</html>
