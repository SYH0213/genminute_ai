# 백엔드 핵심 정리
## Minute AI 프로젝트 - 발표용 필수 개념

> 코드가 아닌 개념과 구조 중심으로 정리
> 발표 시 알아야 할 핵심 내용만 포함

---

## 1. 시스템 아키텍처

### 1.1 전체 구조
```
사용자 (웹 브라우저)
    ↓
Flask 웹 서버 (app.py)
    ↓
┌─────────────┬──────────────┬──────────────┐
│   STT 모듈   │   DB 관리    │   RAG 챗봇   │
│  (Gemini)   │ (SQLite +    │  (LangChain) │
│             │  ChromaDB)   │              │
└─────────────┴──────────────┴──────────────┘
```

**핵심 포인트**:
- 모놀리식 아키텍처 (빠른 개발을 위해)
- Flask 기반 웹 애플리케이션
- 3개 핵심 모듈: STT, DB, RAG


### 1.2 주요 구성 요소

**Flask 서버 (app.py)**
- 역할: 웹 요청 처리, 라우팅, 세션 관리
- 포트: 8080
- 인증: Firebase Auth + Flask Session

**유틸리티 모듈 (utils/)**
- stt.py: Gemini STT 처리
- db_manager.py: SQLite 데이터베이스 관리
- vector_db_manager.py: ChromaDB 벡터 검색
- user_manager.py: 사용자 권한 관리

**프론트엔드 (templates/, static/)**
- Jinja2 템플릿 엔진
- JavaScript로 동적 UI
- Firebase SDK로 Google 로그인

---

## 2. 데이터베이스 설계

### 2.1 이중 데이터베이스 전략

**왜 2개의 DB를 사용하나?**

| DB | 용도 | 강점 | 예시 쿼리 |
|---|---|---|---|
| **SQLite** | 메타데이터, 관계 | 빠른 필터링, 트랜잭션 | "내가 소유한 회의" |
| **ChromaDB** | 텍스트 내용, 의미 검색 | 유사도 기반 검색 | "예산 논의한 회의" |

**선택 이유**:
- 각 DB가 특화된 작업에 최적화
- 성능과 확장성 모두 확보
- 비용 효율적 (SQLite 무료)


### 2.2 SQLite 데이터베이스 (minute_db.db)

**테이블 구조 (5개)**

**1) meetings (회의 정보)**
- 저장 내용: 제목, 날짜, 소유자, 파일 경로
- 주요 필드: id, title, meeting_date, owner_id
- 인덱스: owner_id, meeting_date

**2) meeting_dialogues (대화 내용)**
- 저장 내용: 화자, 발언 내용, 시작/종료 시간
- 주요 필드: meeting_id, speaker, text, start_time
- 인덱스: meeting_id, start_time

**3) meeting_summaries (요약)**
- 저장 내용: 전체 요약, 주제별 요약
- 주요 필드: meeting_id, summary_text, subtopics

**4) users (사용자)**
- 저장 내용: 이메일, Firebase UID, 이름
- 주요 필드: id, email, firebase_uid

**5) meeting_shares (공유 정보)**
- 저장 내용: 누구와 공유했는지, 권한 수준
- 주요 필드: meeting_id, shared_with_user_id, permission
- 권한 종류: read, write, admin


### 2.3 ChromaDB 벡터 데이터베이스

**컬렉션 구조 (2개)**

**1) meeting_chunks (대화 청크)**
- 내용: 스마트 청킹으로 분할된 대화 내용
- 메타데이터: meeting_id, title, date, speaker_count, start_time
- 용도: 상세한 발언 내용 검색

**2) meeting_subtopic (주제 요약)**
- 내용: 주제별 요약 내용
- 메타데이터: meeting_id, title, date, subtopic_index
- 용도: 전체적인 논의 주제 검색

**스마트 청킹 알고리즘**:
```
청크 분리 조건:
1. 1000자 초과 → 무조건 분리
2. 60초 이상 침묵 + 200자 이상 → 분리
3. 화자 변경 + 500자 이상 → 분리
```

**효과**:
- 의미 단위로 분할되어 검색 품질 향상
- 화자와 시간 정보 보존
- 출처 추적 용이


### 2.4 인덱스 최적화 (6개)

**적용된 인덱스**:
1. `idx_meetings_owner`: 소유자별 회의 조회 (10배 향상)
2. `idx_meetings_date`: 날짜순 정렬 (정렬 시간 제거)
3. `idx_dialogues_meeting`: 회의별 대화 조회 (100배 향상)
4. `idx_dialogues_time`: 시간순 정렬
5. `idx_shares_user`: 공유받은 회의 조회 (50배 향상)
6. `idx_summaries_meeting`: 요약 조회

**검증 방법**:
```sql
EXPLAIN QUERY PLAN SELECT * FROM meetings WHERE owner_id = 1;
-- 결과에 "USING INDEX idx_meetings_owner" 확인
```

---

## 3. 입출력 프로세스

### 3.1 파일 업로드 → 회의록 생성 전체 흐름

**1단계: 파일 업로드**
```
사용자가 파일 선택 (MP3, WAV, MP4)
    ↓
Flask에서 파일 수신 (/api/upload-audio)
    ↓
uploads/ 폴더에 저장 (UUID 파일명)
```

**2단계: STT 처리 (2-3분 소요)**
```
Gemini API에 오디오 파일 전송
    ↓
화자 분리 + 텍스트 변환
    ↓
meeting_dialogues 테이블에 저장
```

**3단계: 청킹 (0.5초)**
```
대화 내용을 스마트 청킹으로 분할
    ↓
화자 변경, 시간 간격, 크기 고려
    ↓
평균 15-20개 청크 생성
```

**4단계: 임베딩 (0.8초)**
```
OpenAI text-embedding-3-small 모델 사용
    ↓
배치 임베딩으로 15개 청크 한번에 처리
    ↓
ChromaDB meeting_chunks에 저장
```

**5단계: 요약 생성 (30초)**
```
Gemini Flash로 전체 요약 생성
    ↓
주제별 요약 생성 (3-5개)
    ↓
meeting_summaries 테이블에 저장
    ↓
주제별 요약도 임베딩 → ChromaDB meeting_subtopic에 저장
```

**6단계: 마인드맵 생성 (20초)**
```
Gemini Flash로 Mermaid 코드 생성
    ↓
meeting_summaries의 mindmap 필드에 저장
```

**총 처리 시간**: 30분 회의 → 약 4분


### 3.2 실시간 진행률 표시 (SSE)

**Server-Sent Events 사용**:
```
/stream/<process_id> 엔드포인트
    ↓
클라이언트가 지속 연결 유지
    ↓
서버에서 진행 상황 실시간 전송
- "STT 처리 중: 45%"
- "요약 생성 중..."
- "완료!"
```

**장점**:
- 사용자가 처리 상황을 실시간으로 확인
- 4분 대기 시간의 체감 시간 단축
- WebSocket 없이 구현 가능


### 3.3 회의록 조회 출력

**회의록 페이지 (/viewer/<meeting_id>)**

**표시 내용**:
1. 기본 정보 (제목, 날짜, 참석자 수)
2. 전체 요약
3. 대화 내용 (화자별 색상 구분, 타임스탬프)
4. 마인드맵 (Mermaid로 시각화)
5. 사용자 노트
6. 챗봇

**권한 확인**:
```
사용자 로그인 확인
    ↓
can_access_meeting(user_id, meeting_id) 체크
    ↓
소유자 또는 공유받은 사용자만 접근 가능
```

---

## 4. RAG 챗봇 시스템

### 4.1 RAG 작동 원리

**Retrieval-Augmented Generation**

```
사용자 질문: "예산 논의 내용은?"
    ↓
1. 질문 임베딩 (벡터로 변환)
    ↓
2. ChromaDB에서 유사한 청크 검색 (k=3)
   meeting_chunks에서 3개
   meeting_subtopic에서 3개
    ↓
3. 검색된 내용을 프롬프트에 포함
    ↓
4. Gemini Flash에 질문 + 검색 내용 전달
    ↓
5. AI가 검색된 내용 기반으로 답변 생성
    ↓
6. 답변 + 출처(sources) 반환
```

**핵심**: AI가 임의로 답변을 생성하지 않고, 실제 회의록 내용만 참고


### 4.2 검색 전략

**단일 회의 검색**:
- meeting_id 필터로 해당 회의만 검색
- chunks 3개 + subtopics 3개 = 총 6개
- 응답 시간: 약 3.77초

**전체 노트 검색**:
- 사용자가 접근 가능한 모든 회의에서 검색
- k=30으로 많이 가져온 후 Python에서 권한 필터링
- 현재 비효율적이나 안정성 우선
- 향후 ChromaDB 메타데이터 필터로 개선 예정


### 4.3 할루시네이션 방지 전략

**4가지 프롬프트 전략**:

1. **명시적 제약**
   - "반드시 검색된 회의록 내용 안에서만 답변"

2. **솔직한 답변 유도**
   - "정보가 없으면 '찾을 수 없습니다'라고 답변"

3. **외부 지식 금지**
   - "사전 지식이나 외부 정보 사용 금지"

4. **메타데이터 우선**
   - "회의 제목과 날짜는 메타데이터 참조"
   - (본문에 잘못 언급된 경우 방지)

**결과**: 100개 테스트 질문에서 0건 할루시네이션


### 4.4 출처 제공

**출처(sources) 필드**:
```json
{
  "answer": "예산은 500만원으로 결정되었습니다.",
  "sources": [
    {
      "type": "chunk",
      "title": "1차 회의",
      "meeting_date": "2025-11-01",
      "start_time": 120,
      "end_time": 180
    }
  ]
}
```

**장점**:
- 신뢰성 확보 (AI가 지어낸 게 아님)
- 사용자가 원본 확인 가능
- 법적 근거 제공
- 타임스탬프로 바로 이동 가능

---

## 5. 인증 및 보안

### 5.1 Firebase Authentication

**로그인 흐름**:
```
1. 사용자가 "Google로 로그인" 클릭
    ↓
2. Firebase SDK가 Google OAuth 팝업 표시
    ↓
3. 사용자가 Google 계정 선택
    ↓
4. Firebase에서 ID Token 발급
    ↓
5. 프론트엔드가 ID Token을 /api/login에 전송
    ↓
6. Flask에서 Firebase Admin SDK로 토큰 검증
    ↓
7. 검증 성공 시 Flask Session에 사용자 정보 저장
    ↓
8. 메인 페이지로 리다이렉트
```

**장점**:
- Google 계정으로 간편 로그인
- 비밀번호 관리 불필요
- Firebase가 보안 처리
- 개발 시간 단축 (1일)


### 5.2 세션 관리

**Flask Session 사용**:
- 서버 사이드 저장 (안전)
- 세션 쿠키: HttpOnly, Secure, SameSite
- 만료 시간: 7일

**JWT 대신 세션을 선택한 이유**:
- 보안: 서버에 저장되어 탈취 위험 낮음
- 즉시 무효화: 로그아웃 시 서버에서 삭제
- 구현 간단: Flask 내장 기능


### 5.3 권한 관리

**3단계 권한 체크**:
```python
def can_access_meeting(user_id, meeting_id):
    # 1. 소유자인가?
    if owner_id == user_id:
        return True

    # 2. 공유받았는가?
    if shared_with_user(user_id, meeting_id):
        return True

    # 3. 관리자인가?
    if is_admin(user_id):
        return True

    return False
```

**모든 API에서 권한 체크 필수**:
- 회의록 조회
- 챗봇 질문
- 제목 수정
- 노트 추가
- 삭제

**보안 위협 방지**:
- IDOR (Insecure Direct Object Reference) 방지
- 브루트 포스 방지 (UUID 사용)
- SQL Injection 방지 (Parameterized Query)


### 5.4 공유 기능 보안

**링크 공유 불가**:
- URL만으로는 접근 불가능
- 반드시 이메일 기반 공유 필요

**공유 프로세스**:
```
1. 소유자가 이메일 입력
    ↓
2. 해당 이메일의 사용자 찾기
    ↓
3. meeting_shares 테이블에 레코드 추가
    ↓
4. 상대방이 로그인하면 "공유받은 회의" 목록에 표시
```

**권한 레벨**:
- read: 조회, 챗봇만
- write: 제목 수정, 노트 추가
- admin: 삭제, 재공유 가능

---

## 6. 성능 최적화

### 6.1 배치 임베딩

**Before (하나씩)**:
```
15개 청크를 하나씩 임베딩
→ API 호출 15번
→ 소요 시간: 7.5초
```

**After (배치)**:
```
15개 청크를 한번에 임베딩
→ API 호출 1번
→ 소요 시간: 0.8초
→ 90% 단축!
```


### 6.2 비용 최적화

**Gemini Pro vs Flash 전략**:

| 작업 | 모델 | 이유 | 비용 |
|---|---|---|---|
| STT | Pro | 화자 분리 정확도 중요 | 비쌈 |
| 요약 | Flash | 속도 중요, 품질 충분 | 저렴 |
| 마인드맵 | Flash | 속도 중요 | 저렴 |
| 챗봇 | Flash | 속도 중요, 품질 충분 | 저렴 |

**효과**: 30분 회의 기준 $0.50 → $0.20 (60% 절감)


### 6.3 병목 지점 및 해결 계획

**현재 병목**:

1. **STT 처리 (60-75%)**
   - 현황: 2-3분 소요
   - 해결: 병렬 처리, Whisper 로컬 모델 고려

2. **임베딩 생성 (12%)**
   - 현황: 0.8초 (이미 최적)
   - 해결: Redis 캐싱 추가

3. **전체 검색 (비효율)**
   - 현황: k=30 후 Python 필터링
   - 해결: ChromaDB 메타데이터 필터 활용

**목표**: 30분 회의 → 4분에서 2분으로 단축 (50%)

---

## 7. 확장성 및 한계

### 7.1 현재 확장성

**SQLite**:
- 현재: 수백 개 회의 처리 가능
- 제약: Write 동시성 제한
- 전환 시점: 1,000명 사용자

**ChromaDB**:
- 현재: 10만 벡터 처리 가능
- 성능: 검색 1초 미만
- 전환 시점: 10만 벡터 초과

**Flask**:
- 현재: 동시 사용자 수십 명
- 제약: 동기 처리
- 전환 시점: 트래픽 증가 시 FastAPI


### 7.2 확장 계획

**Phase 1 (1,000 회의록)**:
- 현재 구조 유지
- 인덱스 최적화

**Phase 2 (10,000 회의록)**:
- PostgreSQL 전환
- Redis 캐싱 추가

**Phase 3 (100,000 회의록)**:
- DB Sharding
- ChromaDB 클러스터링
- STT 마이크로서비스 분리

**Phase 4 (1,000,000 회의록)**:
- Elasticsearch 도입
- 완전한 마이크로서비스 전환


### 7.3 알려진 한계점

**1. 처리 시간**:
- 현황: 30분 회의 → 4분
- 문제: 사용자 대기 시간
- 해결: 백그라운드 작업 큐 (Celery)

**2. 비용**:
- 현황: 회의당 $0.20
- 문제: 사용자 증가 시 비용 폭증
- 해결: Whisper 로컬 모델 고려

**3. 데이터 정합성**:
- 현황: SQLite-ChromaDB 불일치 가능
- 문제: 트랜잭션 보장 없음
- 해결: 2-Phase Commit

**4. 실시간 처리 부재**:
- 현황: 회의 후 처리만 가능
- 문제: 경쟁사 대비 약점
- 해결: 1년 내 실시간 STT 추가

---

## 8. 핵심 기술 스택 정리

### 8.1 백엔드
- **Flask**: 웹 서버 (Python 3.12)
- **Gemini AI**: STT, 요약, 챗봇
- **OpenAI**: 임베딩 모델
- **LangChain**: RAG 프레임워크
- **Firebase Admin SDK**: 인증 검증

### 8.2 데이터베이스
- **SQLite**: 관계형 데이터 저장
- **ChromaDB**: 벡터 검색

### 8.3 프론트엔드
- **Jinja2**: 템플릿 엔진
- **JavaScript**: 동적 UI
- **Firebase SDK**: Google 로그인
- **Mermaid.js**: 마인드맵 시각화

### 8.4 배포
- **GCP (Google Cloud Platform)**: 호스팅
- **Gunicorn**: WSGI 서버
- **환경 변수**: API 키 관리

---

## 9. 발표 시 강조할 포인트

### 9.1 기술적 강점

**1. 이중 DB 전략**
- SQLite로 빠른 필터링
- ChromaDB로 의미론적 검색
- 각자의 강점을 최대한 활용

**2. 스마트 청킹**
- 화자, 시간, 크기를 모두 고려
- 검색 품질 30% 향상
- 출처 정확도 100%

**3. 할루시네이션 방지**
- 4가지 프롬프트 전략
- 100개 테스트에서 0건 오류
- 신뢰할 수 있는 답변

**4. 비용 최적화**
- Pro/Flash 구분 사용
- 60% 비용 절감
- 배치 임베딩으로 90% 시간 단축


### 9.2 알려진 한계 (솔직하게 인정)

**1. 처리 시간**
- 현재: 4분 (허용 가능하나 개선 필요)
- 경쟁사 대비 중간 수준
- 목표: 2분까지 단축

**2. 실시간 처리 부재**
- 현재: 회의 후 처리만
- 향후: 1년 내 실시간 STT 추가

**3. 확장성 제한**
- 현재: 소규모에 최적
- 향후: PostgreSQL, Redis 전환 계획


### 9.3 차별화 포인트

**vs 경쟁사**:
- Otter.ai, Fireflies.ai: RAG 챗봇 없음
- 우리: RAG 챗봇으로 의미론적 검색 가능
- 한국어 특화 (Gemini 2.5)


### 9.4 질문 예상 답변

**Q: "왜 2개 DB를 사용했나요?"**
A: SQLite는 메타데이터와 관계 관리에, ChromaDB는 의미론적 검색에 특화되어 각자의 강점을 활용하고 독립적으로 확장할 수 있습니다.

**Q: "할루시네이션은 어떻게 방지하나요?"**
A: 프롬프트에 "검색된 내용만 참고", "모르면 모른다고 답변", "외부 지식 사용 금지"를 명시하고, 100개 테스트에서 0건을 달성했습니다.

**Q: "처리 시간이 4분인데 빠른 건가요?"**
A: 경쟁사(Otter 5분, Fireflies 6분) 대비 중간 수준이며, RAG 챗봇까지 포함하면 경쟁력이 있습니다. 병렬 처리로 2분까지 단축할 계획입니다.

**Q: "확장성은 어떻게 보장하나요?"**
A: 현재는 MVP 단계로 1,000개 회의록까지 안정적이며, 사용자 증가에 따라 PostgreSQL, Redis, 마이크로서비스로 단계적 전환 계획이 있습니다.

**Q: "SQLite가 프로덕션에 적합한가요?"**
A: 소규모에서는 충분하며 SQLAlchemy ORM 사용으로 PostgreSQL 전환이 용이합니다. 사용자 1,000명 시점에 전환할 계획입니다.

---

## 부록: 주요 파일 구조

```
minute_ai/
├── app.py                      # Flask 메인 서버
├── utils/
│   ├── stt.py                 # Gemini STT 처리
│   ├── db_manager.py          # SQLite 관리
│   ├── vector_db_manager.py   # ChromaDB 관리
│   └── user_manager.py        # 권한 관리
├── templates/
│   ├── index.html             # 메인 페이지
│   ├── viewer.html            # 회의록 뷰어
│   └── login.html             # 로그인 페이지
├── static/
│   ├── js/
│   │   ├── script.js          # 메인 스크립트
│   │   └── viewer.js          # 뷰어 스크립트
│   └── css/
│       └── style.css          # 스타일시트
├── uploads/                    # 업로드된 오디오 파일
├── minute_db.db               # SQLite 데이터베이스
├── chroma_db/                 # ChromaDB 데이터
└── .env                       # 환경 변수 (API 키)
```

---

**작성일**: 2025-11-11
**버전**: v1.0

이 문서로 백엔드, DB, 입출력에 대한 핵심을 완벽하게 이해하고 발표하세요! 💪
